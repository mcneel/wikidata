====== Display Conduit Introduction for RhinoCommon DRAFT ======
> **Summary:** //A How-To introduction to writing display conduits//

Rhino5 allows you to define your own display conduits, which provide access to many levels of the display pipeline. They are a bit tricky, hence this Wiki page.

The DisplayPipeline in Rhino5 is a big and complicated class and we do not recommend you try and derive your own pipeline, instead, we've exposed something called a "conduit" for easy access. The pipeline itself is structured like this (except in reality there are many more channels):

{{http://en.wiki.mcneel.com/content/upload/images/PipeLineImageA.jpg}}

At one end is the Rhino model, a collection of 3D geometry and data. At the other end is the image we want to display on the screen, a collection of 2D pixels. In order to get from model to image, the pipeline has to process a lot of information. These steps have been put into things we call Channels. Whenever you implement a new conduit, you have to implement at least one of these channels, like so:

{{http://en.wiki.mcneel.com/content/upload/images/PipeLineImageB.jpg}}

Note that the pipeline itself is not bound to the channels, it just executes its code and every once and again it calls the conduits who perceive this as a new channel execution. This means that you cannot disable certain portions of the pipeline (or portions of other conduits) from within your conduit. The pipeline has to go through these motions to generate an image:

Note that the pipeline itself is not bound to the channels, it just executes its code and raises events during specific phases of drawing.  During the drawing of a single frame the events are raised in the following order:

  - ObjectCulling: Create a list of all the objects to draw.
  - CalculateBoundingBox: Determine the extent of the entire scene.  Override this function to increase the bounding box of scene so it includes the geometry that you plan to draw.  
  - CalculateBoundingBoxZoomExtents: If you want to participate in the Zoom Extents command with your display conduit, then you will need to override ZoomExtentsBoundingBox.  Typically you could just call your CalculateBoundingBox override, but you may also want to spend a little more time here and compute a tighter bounding box for your conduit geometry if that is needed.
  - #CalculateClippingPanes - Calculate the depth of the z-buffer based on the boundingbox 
  - #SetupFrustum - Load projection {camera; target; lens length; etc.} and calculate world-to-screen transformations 
  - #SetupLighting - Create a lighting environment to be used in Shaded modes 
  - #InitializeFrameBuffer - Set up the drawing buffer so we have something to draw on 
  - #DrawBackground - Draw the background of the scene. This includes the viewport color, BackgroundBitmaps and grids 
  - If this is a layout and detail objects exist the channels are called in the same order for each detail object (drawn as a nested viewport)
  - PreDrawObjects - Prepare for the drawing of an object, i.e. set up the display attributes for it 
  - For Each Visible Non Highlighted Object
  - PostDrawObjects - depth writing/testing on - Draw stuff on top of all the objects, like selection wireframes etc. 
  - DrawForeGround - depth writing/testing off - Draw the foreground, like the little axis-system in the lower left corner of viewports 
  - For Each Visible Highlighted Object
  - #PostProcessFrameBuffer (If a delegate exists that requires this) - Perform pixel operations on the framebuffer (such as contrast and brightness adjustments) 
  - DrawOverlay (if Rhino is in a feedback mode)

You hook into the pipeline by extending DisplayConduit and overriding the key event handlers which have the same name as the pipeline events.

In the above case, the conduit overrode two event handlers; CalculateBoundingBox and PostDrawObjects. In C# this conduit would look like:
<code c#>
  class MyConduit : Rhino.Display.DisplayConduit
  {
    protected override void CalculateBoundingBox(CalculateBoundingBoxEventArgs e)
    {
      base.CalculateBoundingBox(e);
      // ..
    }

    protected override void PostDrawObjects(DrawEventArgs e)
    {
      base.PreDrawObjects(e);
      // ..
    }
  }
</code>
By default, conduits are not enabled but it is easily done by setting the Enadled property of the DisplayConduit to True.
<code c#>
  var conduit = new MyConduit();
  conduit.Enabled = true;
</code>
 Once our conduit is constructed and enabled, the overriden methods will be called whenever the Rhino pipeline raises the event for which our overriden method is registered.  In our case, this method will always be called once with the CalculateBoundingBox and the PostDrawObjects events have been raised (the events have the same name as the overriden methods). Here's a simple example:
<code c#>
  class MyConduit : Rhino.Display.DisplayConduit
  {
    protected override void CalculateBoundingBox(CalculateBoundingBoxEventArgs e)
    {
      base.CalculateBoundingBox(e);
      e.BoundingBox.Union(new Point3d(0,0,0);
    }

    protected override void PreDrawObjects(DrawEventArgs e)
    {
      base.PreDrawObjects(e);
      e.Display.DrawPoint(new Point3d(0,0,0);
    }
  }
</code>
The code above simply draws a single point at the world origin. Since a point is 3D geometry, it is subject to z-depth clipping. This means that if the point resides outside the z-buffer region, it will not be visible (it will get "clipped"). By default, the clipping planes are set up to encompass the boundingbox of the entire Rhino model. If you're drawing stuff which is potentially outside this box, you should override CalculateBoundingBox to make sure your objects are not clipped.

Let's take a look at a more complex drawing routine:
<code c#>
   protected override void CalculateBoundingBox(CalculateBoundingBoxEventArgs e)
   {
     base.CalculateBoundingBox(e);
     e.BoundingBox.Union(e.Display.Viewport.ConstructionPlane().Origin);
   }

   protected override void PreDrawObjects(DrawEventArgs e)
   {
     base.PreDrawObjects(e);

     var cPlane = e.Display.Viewport.ConstructionPlane();
     var xColor = Rhino.ApplicationSettings.AppearanceSettings.GridXAxisLineColor;
     var yColor = Rhino.ApplicationSettings.AppearanceSettings.GridYAxisLineColor;
     var zColor = Rhino.ApplicationSettings.AppearanceSettings.GridZAxisLineColor;

     e.Display.EnableDepthWriting(false);
     e.Display.EnableDepthTesting(false);

     e.Display.DrawPoint(cPlane.Origin, System.Drawing.Color.White);
     e.Display.DrawArrow(new Line(cPlane.Origin, new Vector3d(cPlane.XAxis) * 10.0), xColor);
     e.Display.DrawArrow(new Line(cPlane.Origin, new Vector3d(cPlane.YAxis) * 10.0), yColor);
     e.Display.DrawArrow(new Line(cPlane.Origin, new Vector3d(cPlane.ZAxis) * 10.0), zColor);

     e.Display.EnableDepthWriting(false);
     e.Display.EnableDepthTesting(false);
   }
</code>
This piece of code draws a coloured, c-plane axis system ON TOP of all objects. Because I disable DepthWriting and Testing prior to drawing my points and arrows, my objects are not obscured by the existing geometry (which was drawn in a channel previous to PostDrawObjects:

{{http://en.wiki.mcneel.com/content/upload/images/ConduitCplaneAxis.jpg}}

Another thing to realize is that there can be many other active conduits present as well and there's no way of telling which one is going to be called first. Do not write code that might screw up other peoples conduits.

{{http://en.wiki.mcneel.com/content/upload/images/PipeLineImageC.jpg}}
{{tag>Developer rhinocommon}}
