====== Projecting Points to Breps ======
====== C++, .NET ======
> **Summary:** //Demonstrates how to project points onto Brep objects.//
> **NOTICE:** //The Rhino.NET SDK is deprecated in Rhino 5.  This example adapted for the new RhinoCommon SDK is [[developer:rhinocommonsamples:projectpointstobreps|here]]//
=====Question=====
Is there a way that I can project a 2-d point (x,y) onto a brep object, using the Rhino SDK, in order to acquire the z-coordinate?

=====Answer=====
Use the **RhinoProjectPointsToBreps** SDK function. In order to use this function you will need to provide the following:

  - An array of one or more Brep objects.
  - An array of one or more points to project.
  - A projection direction (vector).

The following sample code demonstrates how you can use this function to accomplish what you want.

===== C++ =====
<code c++>

CRhinoCommand::result CCommandFoobarCpp::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt(L"Select surface or polysurface");
  go.SetGeometryFilter(
    CRhinoGetObject::surface_object | 
    CRhinoGetObject::polysrf_object
    );
  go.GetObjects(1, 1);
  if (go.CommandResult() != CRhinoCommand::success)
    return go.CommandResult();

  const ON_Brep* brep = go.Object(0).Brep();
  if (0 == brep)
    return CRhinoCommand::failure;

  ON_3dPoint point(0.0, 0.0, 0.0); // some point on the world x-y plane

  // Prepare input to RhinoProjectPointsToBreps

  ON_SimpleArray<const ON_Brep*> Breps;
  Breps.Append(brep);

  ON_3dPointArray Points;
  Points.Append(point);

  ON_3dVector ProjDir(0.0, 0.0, 1.0); // world z-axis

  ON_3dPointArray OutPoints;
  ON_SimpleArray<int> Indices;

  bool rc = RhinoProjectPointsToBreps(
    Breps, 
    Points, 
    ProjDir, 
    OutPoints, 
    Indices,
    context.m_doc.AbsoluteTolerance()
    );

  if (rc == true)
  {
    for (int i = 0; i < OutPoints.Count(); i++)
    {
      ON_3dPoint pt = OutPoints[i];
      context.m_doc.AddPointObject(pt);
    }
    context.m_doc.Redraw();
  }

  return CRhinoCommand::success;
}

</code>
===== C# =====
<code c#>

public override IRhinoCommand.result RunCommand(IRhinoCommandContext context)
{
  MRhinoGetObject go = new MRhinoGetObject();
  go.SetCommandPrompt("Select surface or polysurface");
  go.SetGeometryFilter(
    IRhinoGetObject.GEOMETRY_TYPE_FILTER.surface_object | 
    IRhinoGetObject.GEOMETRY_TYPE_FILTER.polysrf_object
    );
  go.GetObjects(1, 1);
  if (go.CommandResult() != IRhinoCommand.result.success)
    return go.CommandResult();

  IOnBrep brep = go.Object(0).Brep();
  if (brep == null)
    return IRhinoCommand.result.failure;

  On3dPoint point = new On3dPoint(0.0, 0.0, 0.0); // some point on the world x-y plane

  // Prepare input to RhinoProjectPointsToBreps

  IOnBrep[] Breps = new IOnBrep[1];
  Breps[0] = brep;

  On3dPointArray Points = new On3dPointArray();
  Points.Append(point);

  On3dVector ProjDir = new On3dVector(0.0, 0.0, 1.0); // world z-axis

  On3dPointArray OutPoints = new On3dPointArray();
  Arrayint Indices = new Arrayint();

  // Do the projection
  bool rc = RhUtil.RhinoProjectPointsToBreps(
    Breps, 
    Points, 
    ProjDir, 
    out OutPoints, 
    out Indices,
    context.m_doc.AbsoluteTolerance()
    );

  if (rc == true)
  {
    for (int i = 0; i < OutPoints.Count(); i++)
    {
      On3dPoint pt = OutPoints[i];
      context.m_doc.AddPointObject(pt);
    }
    context.m_doc.Redraw();
  }

  return IRhinoCommand.result.success;
}

</code>


{{tag>Developer cplusplus dotnet}}
