====== A basic tutorial on creating macros (scripting with Rhino commands) ======

======Introduction======

Scripting macros in Rhino is a way to automate many tasks, customize your commands and improve your workflow.

There may be some confusion about the term “scripting” as it used rather loosely to describe both the process of writing macros (what this section is all about), as well as writing more sophisticated “scripts” in either [[developer:rhinoscript|RhinoScript]] or VB script programming languages, which are very different.

I will use the term “Macro” here exclusively to describe the putting together of strings of ordinary Rhino commands and their options to create an automated function.  This is “scripting” on its simplest of levels, and is easily accessible to any ordinary Rhino user, even if they have no knowledge of programming.  All that is needed is a reasonable understanding of Rhino commands and their structure, as well as a logical mind and a taste for a little experimentation and debugging.


=====The tools you need:=====
Your brain

The Rhino Help file -  lists all Rhino commands and their sub-options, this is your most important reference.

The Rhino V4 or V3 SR4+ Bonus tool **MacroEditor**, which will allow you to easily run and debug your macros.

=====You've already used a macro or two...=====
First, if you are a user of Rhino, you are already a user of macros even though you may not know it.  Many of the commands in Rhino are already “macroed” for you, when you click a toolbar button or call a command from the menu, it is often a preset macro.  To see, Shift+Right click on the button **Extrude Straight**:

{{:legacy:en:ExtrudeCrvButtonEditor.gif}}
This an example of the simplest type of macro, which simply sets a series of options within a single command so that you don’t have to specify each one every time you use it.  **ExtrudeCrv** has several buttons with pre-set options, //Tapered//, //AlongCurve//, //ToPoint//, //Cap=Yes// (solid) etc.  Check out the macros under all the **ExtrudeCrv** buttons to see how they are laid out.

In a sense, you’re doing the same thing as if you clicked or typed the options one at a time at the command line.  In fact, that’s all macros really are, just a set of instructions to repeat a sequence of commands you would have otherwise input manually one at a time.

This scripting of options for a single command can also be combined with data entry (i.e. coordinates or other numerical data). It is also possible to string together several commands in a row, resulting in an automated sequence of “events” for manipulating or creating objects.

> **Note:** //Why the _Underscores?  These tell Rhino that the command which follows is in English (no matter what the language you are running Rhino in), which will make your macro “universal”.  If you are running in English and don’t care, you can eliminate them in your macros if you wish, it will not affect anything else.  Also:Why the exclamation point (!) ?  This cancels any previous command that might be running for safety's sake.//

======Getting Started======

Let’s say you have to place a series of 10 x 10 x 10 boxes with the center of the bottom face landing at the desired point, that point to be specified by either by a mouse click at the desired location or by keyboard entering the coordinates.

One could use the standard Box (Corner to Corner + Height) command, but by default, this will place the insertion point at the first corner of the box.  To have the insertion point where we want, it is easier to use the Box, Center command.   This is in reality just the Box command with the “center” option, so in your macro you will have to activate it.

Open the **MacroEditor**,  type this in:

  ! //Box //Center  (this is actually the macro under the Box, Center button if you check)
All entries (command words and numerical inputs) need to be separated by a single space.

Now, we need to specify the center point.  In order to do this, one needs to tell Rhino to stop processing the command temporarily and wait for a user input in the form of a click or a keyboard entry.  This is accomplished by inserting the command Pause.

  ! //Box //Center _Pause
Once the data has been entered, we can specify the size of the box directly in the command.  Since the Center option in Box wants a corner of the box as a second input, we can specify its X,Y coordinates:

  ! //Box //Center _Pause r5,5
(Why the “r”?  we want this coordinate to be relative to the last picked point, that is to say, the box bottom center.  Otherwise the corner will always land at X5, Y5.)

At this point we can put in the height, which in this case is relative to the original starting point

  ! //Box //Center _Pause r5,5 10
Since there is no further input necessary nor options possible, the macro completes and our box is there.  Note that since we wanted a height equal to the width, another possibility  would just to have been to use Enter instead of 10 for the last entry.

  ! //Box //Center //Pause r5,5 //Enter
Now that the macro is running and you are satisfied, [[rhino:macroscriptsetup|make a new toolbar button]] and paste the macro in, give it a recognizable name, like “10 x 10 x 10 bottom centered box”  Note, once the macro has been executed once, right clicking will repeat the whole sequence of this macro, so you can use it many times in a row without clicking the button every time.

======OK, let’s get a bit more complicated…======

Some commands invoke dialog boxes with many options.  This would normally stop your macro and wait for you to click the desired options, then continue.  Since you want to automate, you can bypass the dialog by putting a –hyphen (also known as a dash) before the command.  Then you can “script in” all your options and the macro will run to completion without needing your intervention.  Some commands have several levels of sub-options.  If you want to see what’s available, type the command at the command line with the hyphen and look to see what’s proposed in terms of options.  Click on the options and see if they have sub-options.

=====Loft two open curves=====
Let’s say you would like to repetitively **Loft** two //OPEN// curves together to form a surface.  Using the standard **Loft** command, you always have to go through the dialog.  If you use the **//–Loft//** version, you can avoid this and things go much faster.  Have a look at the following:

{@
====== _-Loft======
_Pause
//Type=//Normal

//Simplify=//None

//Closed=//No

_Enter
}@
Note that the command is invoked, and then immediately after the pause which allows you to pick your curves.  If the pause is removed, the macro won’t work if you have not selected your curves before calling it.  If you have already preselected your curves, no matter, the pause is intelligently ignored.  Then command then proceeds set all your specified options, and once that is done, it actually creates the surface and finishes. Try it with two open curves, either pre or post selecting them.  Try modifying one or more of the options, like substituting ////Closed=//Yes//, or ////Simplify=//Rebuild// (for this you will also have to add a line with ////Rebuild=//20// or some other value).

=====Modifying it for use with closed curves=====
Now, try it with two closed curves.  You will have a problem.  Why? For closed curves, Loft needs another input from you – the seam location.  This is something that needs to be specified in the macro in the right sequence.  So, you can either choose from various automatic seam options (which are on a sub-option level) or you can adjust it on screen.  Either way, you need to modify the macro.

Adding a pause in the right place will allow you to check and adjust the seam on screen:

{@
====== _-Loft======
_Pause
_Pause  <--
//Type=//Normal

//Simplify=//None

//Closed=//No

_Enter
}@
Adding an Enter instead of the Pause tells Rhino you don’t care, just leave the seam the way it is by default.

{@
====== _-Loft======
_Pause
_Enter  <--
//Type=//Normal

//Simplify=//None

//Closed=//No

_Enter
}@
Or, you can specify another Loft seam option by stepping down into the seam sub-option level:

{@
====== _-Loft======
_Pause
_Natural  <--
_Enter    <--
//Type=//Normal

//Simplify=//None

//Closed=//No

_Enter
}@
(the Enter after Natural is necessary to exit the “seam” option level and get back up to the Loft options level)

<color darkslateblue>**//Unfortunately, the same macro will not work correctly for both open and closed curves because of the extra seam option required.  This is one of the limitations of the macro system and the way some Rhino commands have been written.//**</color>


======Using Macros to set your interface options quickly======

Macros can also be used to set various GUI and Document Properties options automatically without having to go wading into the Options dialog.  I use the following to set the render mesh the way I want it (note the dash before -_DocumentProperties)

{@
-_DocumentProperties
//Mesh  //Custom

//MaxAngle=0  //AspectRatio=0

//MinEdgeLength=0  //MaxEdgeLength=0

//MaxEdgeSrf=0.01  //GridQuads=16

//Refine=Yes  //JaggedSeams=No

_SimplePlanes=No
_Enter
_Enter
}@
Why two Enters at the end?

Well you went down two levels in -_DocumentProperties, first to the Mesh level, then to the Custom sublevel inside Mesh.  You need one Enter to exit the sublevel and go back to the main level, and one more to exit the command.  Some scripts might even require three enters.  The following is from Jeff LaSor, for turning on or off the crosshair cursor:

To script Crosshairs  ON or OFF you would put the following on a button:

  -//Options //Appearance //Visibility //Crosshairs //Enter //Enter _Enter
Notice the reference to each individual command option name.  Specifying them inside the script is like clicking on them with the mouse.  Also note the 3 'enter' entries.  Since each command option (in this case) takes you down into a new set of sub-level command options, an 'enter' is required to take you back up.  Since this script went down 3 levels, it needs to specify 3 enters to get all the way out of the command.

OR, if you just use an exclamation point '!' at the end (which in a script means “end now!”), it will take you all the way out regardless of how many sub-levels you're in. Note – if you want to continue your macro with something else, do not use !, use the enters instead, otherwise your macro will always stop at the ! and terminate.

The script above simply toggles the crosshairs ON and OFF, but let's say you wanted a script that always turned them ON and another that always turned them OFF...here's what they would look like:

Always ON version:

  -//Options //Appearance //Visibility //Crosshairs=_Show !
Always OFF version:

  -//Options //Appearance //Visibility //Crosshairs_=Hide !
Note the use of the '!' here as mentioned above.... Also note that whatever values options can take on can be assigned directly to that option using the '=' operator.  The Crosshairs option has 2 possible values, "Show" and "Hide", and thus, that's what is used in the assignment.

(Thanks, Jeff)

======Other useful macro writing tools and commands======

There are some handy tricks for doing more complex macros.  One is the discriminating use of various selection filters, particularly the use of **SelLast**, which select the last object created/transformed, **SelPrev**,  which selects the previous input object, and **SelNone**, which deselects everything.  There are also possibilities to name objects, group them (and name the group) and then recall them later by that object name or group name.

{@
Select

SelLast

SelPrev

SelNone

SetObjectName

SetGroupName

SelGroup

SelName

Group

Ungroup

}@
To set a single object name (this in itself is a macro!):

  //Properties //Pause //Object //Name [put your object name here] //Enter //Enter
To cancel a single object name (without deleting the object)

  //Properties //Pause //Object //Name “ “ //Enter //Enter (quote space quote for the name)
=====Examples using the above tools=====
Have a look at the following macro:

{@
====== Select Pause _Setredrawoff======
//BoundingBox //World _Enter

//Selnone //Sellast

//OffsetSrf //Solid _Pause

//Delete //Sellast

//BoundingBox //World _Enter

//Delete //Setredrawon

}@
It creates an offset bounding box around an object, the offset is input by the user.  See if you can follow the logical sequence.  The Setredrawoff/on stop/restart the screen refresh, which eliminates the display flickering as all is executed, and speeds up the process.  Beware, if you terminate the command before Setredrawon, you will think Rhino is dead, as the screen no longer updates.  If this happens, don’t panic, typing the command (Setredrawon) will restore the display refresh.

**//As a final example,//** the following macro creates a point centered on a 2D planar or text object and grouped with it. It pre-supposes that you're in the same view the text was created in, and that the object is really 2D and planar (otherwise it will likely fail).

Note the use of a named group and various selection commands.  The **NoEcho** command temporarily stops the reporting of information to the command line, which, combined with Setredrawoff/on makes the macro run without flashing and without too much info being reported to command history.  It will run without those as well, though.

{@
====== Select Pause Noecho Setredrawoff======
//Group //Enter _SetGroupName TexTemp

//BoundingBox //CPlane _Enter

//SelNone //SelLast //PlanarSrf //SelPrev //Delete //SelLast

//AreaCentroid //Delete //Sellast //SelGroup TexTemp

//Ungroup //Group _Setredrawon

}@
==Please feel free to add to or edit this tutorial!==
This is a work in progress...


