====== Sweeping Surfaces Using Dynamically Created Curves ======

> **Developer:** //[[developer:dotnetplugins|.NET]]//
> **Summary:** //Demonstrates how to use **RhinoSweep1** using dynamically created input curves//

===== Question =====
I am trying to use the **RhUtil.RhinoSweep1** function in .NET SDK (C#) and I am using this example as a basis: [[http://wiki.mcneel.com/developer/sdksamples/sweep1|Sweeping Surfaces with Sweep1]]

This works. But rather than selecting the cross-section curves using the **MRhinoGetObjects** methods, I would like to pass the cross-section curves to this function as an **OnPolyline**, **OnCircle** or other **OnCurve** object which is created based on user data stored on the rail curve. 

But in this case I can no longer get the **RhUtil.RhinoSweep1** function to work because I am unable to pass all the arguments to the **MArgsRhinoSweep1** object. 

===== Answer =====
The following example demonstrates how to sweep a surface, using **RhUtil.RhinoSweep1**, without using **IRhinoObject** objects as input to an**MArgsRhinoSweep1** object.

==== C# ====

<code c#>
public override IRhinoCommand.result RunCommand(IRhinoCommandContext context)
{
  // Define geometry for rail and shape curves
  On3dPoint start_point = new On3dPoint(0,0,0);
  On3dPoint end_point = new On3dPoint(10, 0, 0);
  OnPlane plane = new OnPlane(OnUtil.On_yz_plane);

  plane.SetOrigin(start_point);
  OnCircle circle0 = new OnCircle(plane, 5);

  plane.SetOrigin(end_point);
  OnCircle circle1 = new OnCircle(plane, 2);

  // Build rail and shape curves
  OnLineCurve line_curve = new OnLineCurve(start_point, end_point);
  OnArcCurve arc_curve0 = new OnArcCurve(circle0);
  OnArcCurve arc_curve1 = new OnArcCurve(circle1);

  // Build poly edge curve
  MRhinoPolyEdge rail_curve = new MRhinoPolyEdge();
  rail_curve.Create(line_curve);

  // Create sweep arguments
  MArgsRhinoSweep1 args = new MArgsRhinoSweep1();

  // Add rail curve and related settings
  args.m_rail_curve = rail_curve;
  args.m_bHaveRailPickPoint = false;
  args.m_bClosed = false;
  args.m_bUsePivotPoint = false;

  // Add shape curves
  List<OnCurve> shape_curves = new List<OnCurve>();
  shape_curves.Add(arc_curve0);
  shape_curves.Add(arc_curve1);
  args.m_shape_curves = shape_curves.ToArray();

  // Specify parameters on rail closest to shapes
  args.m_rail_params.Append(rail_curve.Domain()[0]);
  args.m_rail_params.Append(rail_curve.Domain()[1]);

  // No starting sweep point
  args.set_m_bUsePoints(0, 0);
  // No ending sweep point
  args.set_m_bUsePoints(1, 0);
  // 0 = Freeform 
  args.m_style = 0;
  // 0 = Do Not Simplify
  args.m_simplify = 0;
  // Sample point count for rebuilding shapes
  args.m_rebuild_count = -1;
  // 0 = don't miter
  args.m_miter_type = 0;
  // Standard tolerances
  args.m_refit_tolerance = context.m_doc.AbsoluteTolerance();
  args.m_sweep_tolerance = context.m_doc.AbsoluteTolerance();
  args.m_angle_tolerance = context.m_doc.AngleToleranceRadians();

  OnBrep[] breps = null;
  if (RhUtil.RhinoSweep1(ref args, out breps))
  {
    for (int i = 0; i < breps.Length; i++)
      context.m_doc.AddBrepObject(breps[i]);
    context.m_doc.Redraw();
  }

  return IRhinoCommand.result.success;
}
</code>

\\

{{tag>Developer dotnet}}