====== Duplicate the Borders of Surfaces ======
====== C++, .NET ======
> **Summary:** //Demonstrates how to duplicate the borders of surfaces and polysurfaces.//

=====Discussion=====
In order to to duplicate the border curves of surfaces and polysurfaces, you need to search the object for naked edges. A naked edges is one that is not connect to other edges. Once a naked edge has been found, simply duplicate the edge curve and add it to the document.

===== C++ =====
<code c++>
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select surface or polysurface" );
  go.SetGeometryFilter( CRhinoGetObject::surface_object |
                        CRhinoGetObject::polysrf_object );
  go.AcceptNothing();
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != success )
    return go.CommandResult();

  const CRhinoObjRef& object_ref = go.Object(0);
  const CRhinoObject* object = object_ref.Object();
  const ON_Brep* brep = object_ref.Brep();
  if( !object | !brep )
    return failure;

  object->Select( false );

  ON_SimpleArray<const ON_Curve*> curve_array( brep->m_E.Count() );

  for( int i = 0; i < brep->m_E.Count(); i++ )
  {
    const ON_BrepEdge& edge = brep->m_E[i];

    // Find only the naked edges 
    if( edge.m_ti.Count() == 1 && edge.m_c3i >= 0 )
    {
      ON_Curve* curve = edge.DuplicateCurve();

      // Make the curve direction go in the natural
      // boundary loop direction so that the curve
      // directions come out consistantly
      if( brep->m_T[edge.m_ti[0]].m_bRev3d )
        curve->Reverse();
      if( brep->m_T[edge.m_ti[0]].Face()->m_bRev)
        curve->Reverse();

      curve_array.Append( curve );
    }
  }

  double tol = 2.1 * RhinoApp().ActiveDoc()->AbsoluteTolerance();
  ON_SimpleArray<ON_Curve*> output_array;

  // Join the curves
  if( RhinoMergeCurves(curve_array, output_array, tol) )
  {
    for( int i = 0; i < output_array.Count(); i++ )
    {
      CRhinoCurveObject* curve_object = new CRhinoCurveObject;
      curve_object->SetCurve( output_array[i]);
      if( context.m_doc.AddObject(curve_object) )
        curve_object->Select();
      else
        delete curve_object;
    }
  }

  // Don't leak memory
  for( int i = 0; i < curve_array.Count(); i++ )
    delete curve_array[i];

  context.m_doc.Redraw();
  return success;
}
</code>
===== VB.NET =====
<code vb>
Public Overrides Function RunCommand(ByVal context As RMA.Rhino.IRhinoCommandContext) As RMA.Rhino.IRhinoCommand.result

    Dim go As New MRhinoGetObject()
    go.SetCommandPrompt("Select surface or polysurface")
    go.SetGeometryFilter(IRhinoGetObject.GEOMETRY_TYPE_FILTER.surface_object Or IRhinoGetObject.GEOMETRY_TYPE_FILTER.polysrf_object)
    go.AcceptNothing()
    go.GetObjects(1, 1)
    If (go.CommandResult() <> IRhinoCommand.result.success) Then
      Return go.CommandResult()
    End If

    Dim object_ref As MRhinoObjRef = go.Object(0)
    Dim obj As IRhinoObject = object_ref.Object()
    Dim brep As IOnBrep = object_ref.Brep()
    If (obj Is Nothing Or brep Is Nothing) Then
      Return IRhinoCommand.result.failure
    End If

    obj.Select(False)

    Dim curve_array As New System.Collections.Generic.List(Of IOnCurve)()

    Dim edge_count As Integer = brep.m_E.Count()
    For i As Integer = 0 To edge_count - 1
      Dim edge As IOnBrepEdge = brep.m_E(i)
      If (edge.m_ti.Count() = 1 And edge.m_c3i >= 0) Then
        Dim curve As OnCurve = edge.DuplicateCurve()
        If (brep.m_T(edge.m_ti(0)).m_bRev3d) Then curve.Reverse()
        If (brep.m_T(edge.m_ti(0)).Face().m_bRev) Then curve.Reverse()
        curve_array.Add(curve)
      End If
    Next

    If (curve_array.Count() = 0) Then
      context.m_doc.Redraw()
      RhUtil.RhinoApp().Print("No borders duplicated." + vbCrLf)
      Return IRhinoCommand.result.nothing
    End If

    Dim tol As Double = 2.1 * context.m_doc.AbsoluteTolerance()
    Dim output_array(0) As OnCurve
    If (RhUtil.RhinoMergeCurves(curve_array.ToArray(), output_array, tol)) Then
      For i As Integer = 0 To output_array.Length - 1
        Dim curve_object As MRhinoCurveObject = context.m_doc.AddCurveObject(output_array(i))
        If (curve_object IsNot Nothing) Then curve_object.Select()
      Next
    End If

    context.m_doc.Redraw()

    Return IRhinoCommand.result.success

  End Function
</code>

===== C# =====
<code c#>
public override IRhinoCommand.result RunCommand(IRhinoCommandContext context)
{
  MRhinoGetObject go = new MRhinoGetObject();
  go.SetCommandPrompt( "Select surface or polysurface" );
  go.SetGeometryFilter( IRhinoGetObject.GEOMETRY_TYPE_FILTER.surface_object |
                        IRhinoGetObject.GEOMETRY_TYPE_FILTER.polysrf_object );
  go.AcceptNothing();
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != IRhinoCommand.result.success )
    return go.CommandResult();

  MRhinoObjRef object_ref = go.Object(0);
  IRhinoObject obj = object_ref.Object();
  IOnBrep brep = object_ref.Brep();
  if( obj == null | brep == null )
    return IRhinoCommand.result.failure;

  obj.Select( false );

  System.Collections.Generic.List<IOnCurve> curve_array =
        new System.Collections.Generic.List<IOnCurve>();

  IOnBrepEdgeArray edges = brep.m_E;
  int count = edges.Count();
  for( int i = 0; i < count; i++ )
  {
    IOnBrepEdge edge = edges[i];
    // Find only the naked edges 
    if( edge.m_ti.Count() == 1 && edge.m_c3i >= 0 )
    {
      OnCurve curve = edge.DuplicateCurve();

      // Make the curve direction go in the natural
      // boundary loop direction so that the curve
      // directions come out consistantly
      if( brep.m_T[edge.m_ti[0]].m_bRev3d )
        curve.Reverse();
      if( brep.m_T[edge.m_ti[0]].Face().m_bRev)
        curve.Reverse();
      curve_array.Add( curve );
    }
  }

  double tol = 2.1 * context.m_doc.AbsoluteTolerance();
  OnCurve[] output_array = new OnCurve[0];
  // Join the curves
  if( RhUtil.RhinoMergeCurves(curve_array.ToArray(), ref output_array, tol) )
  {
    for( int i = 0; i < output_array.Length; i++ )
    {
      MRhinoCurveObject c = context.m_doc.AddCurveObject(output_array[i]);
      if( c != null )
        c.Select();
    }
  }

  context.m_doc.Redraw();
  return IRhinoCommand.result.success;
}

</code>


{{tag>Developer cplusplus dotnet}}
