====== How To: Divide a Curve by Segments ======
====== C++, .NET ======

The following sample code demonstrates how to divide a selected curve object by a specified number of segments.

===== C++ =====
<code c++>
CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select curve to divide" );
  go.SetGeometryFilter( CRhinoGetObject::curve_object );
  go.GetObjects( 1, 1 );

  if( go.Result() == CRhinoGet::cancel )
    return CRhinoCommand::cancel;

  if( go.Result() != CRhinoGet::object | go.ObjectCount() <= 0 )
    return CRhinoCommand::failure;

  CRhinoObjRef& objref = go.Object(0);
  const ON_Curve* crv = objref.Curve();
  if( !crv )
    return CRhinoCommand::failure;

  CRhinoGetInteger gi;
  gi.SetCommandPrompt( L"Number of segments" );
  gi.SetDefaultInteger( 2 );
  gi.SetLowerLimit( 2 );
  gi.SetUpperLimit( 100 );
  gi.GetInteger();

  if( gi.Result() == CRhinoGet::cancel )
    return CRhinoCommand::cancel;

  if( gi.Result() != CRhinoGet::number )
    return CRhinoCommand::failure;

  int count = gi.Number();
  count++;
  ON_SimpleArray<double> t( count );
  t.SetCount( count );

  int i;
  for( i = 0; i < count; i++ )
  {
    double param = (double)i / ((double)count-1);
    t[i] = param;
  }
  if( crv->GetNormalizedArcLengthPoints(count, (double*)&t[0], (double*)&t[0]) )
  {
    for( i = 0; i < count; i++ )
    {
      ON_3dPoint pt = crv->PointAt( t[i] );
      context.m_doc.AddPointObject( pt );
    }
    context.m_doc.Redraw();
  }
  return CRhinoCommand::success;
}
</code>
===== VB.NET =====
<code vb>
Public Overrides Function RunCommand(ByVal context As IRhinoCommandContext) _
  As IRhinoCommand.result

  Dim go As New MRhinoGetObject()
  go.SetCommandPrompt("Select curve to divide")
  go.SetGeometryFilter(IRhinoGetObject.GEOMETRY_TYPE_FILTER.curve_object)
  go.GetObjects(1, 1)

  If (go.GetResult() = IRhinoGet.result.cancel) Then
    Return IRhinoCommand.result.cancel
  End If
  If (go.GetResult() <> IRhinoGet.result.object Or go.ObjectCount() <= 0) Then
    Return IRhinoCommand.result.failure
  End If

  Dim objref As MRhinoObjRef = go.Object(0)
  Dim crv As IOnCurve = objref.Curve()
  If (crv Is Nothing) Then Return IRhinoCommand.result.failure

  Dim gi As New MRhinoGetInteger()
  gi.SetCommandPrompt("Number of segments")
  gi.SetDefaultInteger(2)
  gi.SetLowerLimit(2)
  gi.SetUpperLimit(100)
  gi.GetInteger()
  If (gi.GetResult() = IRhinoGet.result.cancel) Then
    Return IRhinoCommand.result.cancel
  End If
  If (gi.GetResult() <> IRhinoGet.result.number) Then
    Return IRhinoCommand.result.failure
  End If

  Dim count As Integer = gi.Number()
  Dim t(count) As Double
  For i As Integer = 0 To count
    t(i) = i / count
  Next

  If (crv.GetNormalizedArcLengthPoints(t, t)) Then
    For i As Integer = 0 To count
      Dim pt As On3dPoint = crv.PointAt(t(i))
      context.m_doc.AddPointObject(pt)
    Next
    context.m_doc.Redraw()
  End If
  Return IRhinoCommand.result.success
End Function
</code>
===== C# =====
<code c#>
public override IRhinoCommand.result RunCommand(IRhinoCommandContext context)
{
  MRhinoGetObject go = new MRhinoGetObject();
  go.SetCommandPrompt("Select curve to divide");
  go.SetGeometryFilter(IRhinoGetObject.GEOMETRY_TYPE_FILTER.curve_object);
  go.GetObjects(1, 1);

  if(go.GetResult() == IRhinoGet.result.cancel)
    return IRhinoCommand.result.cancel;

  if(go.GetResult() != IRhinoGet.result.@object | go.ObjectCount() <= 0)
    return IRhinoCommand.result.failure;

  MRhinoObjRef objref = go.Object(0);
  IOnCurve crv = objref.Curve();
  if(crv == null)
    return IRhinoCommand.result.failure;

  MRhinoGetInteger gi = new MRhinoGetInteger();
  gi.SetCommandPrompt("Number of segments");
  gi.SetDefaultInteger(2);
  gi.SetLowerLimit(2);
  gi.SetUpperLimit(100);
  gi.GetInteger();
  if(gi.GetResult() == IRhinoGet.result.cancel)
    return IRhinoCommand.result.cancel;
  if(gi.GetResult() != IRhinoGet.result.number)
    return IRhinoCommand.result.failure;

  int count = gi.Number();
  double[] t = new double[count];
  for( int i=0; i<count; i++ )
    t[i] = (double)i / (double)count;

  if(crv.GetNormalizedArcLengthPoints(t, ref t))
  {
    for( int i=0; i<count; i++ )
    {
      On3dPoint pt = crv.PointAt(t[i]);
      context.m_doc.AddPointObject(pt);
    }
    context.m_doc.Redraw();
  }
  return IRhinoCommand.result.success;
}

</code>


{{tag>Developer cplusplus dotnet}}
