====== How To: Divide a Curve by Length ======
> **Summary:** //Demonstrates how to divide a curve object by a specified length.//

The following sample code demonstrates how to divide a selected curve object by a specified length.

===== C++ =====
<code c++>
CRhinoCommand::result CCommandTest::RunCommand( 
      const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select curve to divide" );
  go.SetGeometryFilter( CRhinoGetObject::curve_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != CRhinoCommand::success )
    return go.CommandResult();

  const CRhinoObjRef& objref = go.Object(0);
  const ON_Curve* crv = objref.Curve();
  if( !crv )
    return CRhinoCommand::failure;

  double crv_length = 0.0;
  crv->GetLength( &crv_length );
  if( crv_length < ON_ZERO_TOLERANCE )
    return CRhinoCommand::failure;

  ON_wString s;
  s.Format( L"Curve length is %g. Segment Length", crv_length );

  CRhinoGetNumber gn;
  gn.SetCommandPrompt( s );
  gn.SetLowerLimit( 0.0, TRUE );
  gn.SetUpperLimit( crv_length, TRUE );
  gn.GetNumber();
  if( gn.CommandResult() != CRhinoCommand::success )
    return gn.CommandResult();

  double seg_length = gn.Number();
  int seg_count = (int)floor( crv_length / seg_length );
  double fractional_end = (seg_count * seg_length) / crv_length;

  double t0, t1;
  crv->GetDomain( &t0, &t1 );
  crv->GetNormalizedArcLengthPoint( fractional_end, &t1 );

  seg_count++;
  ON_SimpleArray<double> t( seg_count );
  t.SetCount( seg_count );

  for( int i = 0; i < seg_count; i++ )
  {
    double param = (double)i / ((double)seg_count-1);
    t[i] = param;
  }

  ON_Interval sub_domain( t0, t1 );
  crv->GetNormalizedArcLengthPoints( seg_count, 
      (double*)&t[0], (double*)&t[0], 
      0.0, 1.0e-8, &sub_domain );

  for( int i = 0; i < seg_count; i++ )
  {
    ON_3dPoint pt = crv->PointAt( t[i] );
    context.m_doc.AddPointObject( pt );
  }

  context.m_doc.Redraw();
  return CRhinoCommand::success;
}
</code>
===== VB.NET =====
<code vb>
Public Overrides Function RunCommand(ByVal context As IRhinoCommandContext) _
  As IRhinoCommand.result
  Dim go As New MRhinoGetObject()
  go.SetCommandPrompt("Select curve to divide")
  go.SetGeometryFilter(IRhinoGetObject.GEOMETRY_TYPE_FILTER.curve_object)
  go.GetObjects(1, 1)
  If (go.CommandResult() <> IRhinoCommand.result.success) Then
    Return go.CommandResult()
  End If

  Dim objref As IRhinoObjRef = go.Object(0)
  Dim crv As IOnCurve = objref.Curve()
  If (crv Is Nothing) Then Return IRhinoCommand.result.failure

  Dim crv_length As Double = 0.0
  crv.GetLength(crv_length)
  If (crv_length < OnUtil.On_ZERO_TOLERANCE) Then
    Return IRhinoCommand.result.failure
  End If

  Dim s As String = String.Format("Curve length is {0:f3}. Segment Length", _
                                  crv_length)
  Dim gn As New MRhinoGetNumber()
  gn.SetCommandPrompt(s)
  gn.SetLowerLimit(0.0, True)
  gn.SetUpperLimit(crv_length, True)
  gn.GetNumber()
  If (gn.CommandResult() <> IRhinoCommand.result.success) Then
    Return gn.CommandResult()
  End If

  Dim seg_length As Double = gn.Number()
  Dim seg_count As Integer = CType(Math.Floor(crv_length / seg_length), Integer)
  Dim fractional_end As Double = (seg_count * seg_length) / crv_length

  Dim t0 As Double = 0
  Dim t1 As Double = 0
  crv.GetDomain(t0, t1)
  crv.GetNormalizedArcLengthPoint(fractional_end, t1)

  Dim t(seg_count) As Double
  For i As Integer = 0 To seg_count
    t(i) = i / seg_count
  Next

  Dim sub_domain As New OnInterval(t0, t1)
  crv.GetNormalizedArcLengthPoints(t, t, 0.0, 0.00000001, sub_domain)
  For i As Integer = 0 To seg_count
    Dim pt As On3dPoint = crv.PointAt(t(i))
    context.m_doc.AddPointObject(pt)
  Next
  context.m_doc.Redraw()
  Return IRhinoCommand.result.success
End Function

</code>
===== C# =====
<code c#>
public override IRhinoCommand.result RunCommand(IRhinoCommandContext context)
{
  MRhinoGetObject go = new MRhinoGetObject();
  go.SetCommandPrompt( "Select curve to divide" );
  go.SetGeometryFilter( IRhinoGetObject.GEOMETRY_TYPE_FILTER.curve_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != IRhinoCommand.result.success )
    return go.CommandResult();

  MRhinoObjRef objref = go.Object(0);
  IOnCurve crv = objref.Curve();
  if( crv == null )
    return IRhinoCommand.result.failure;

  double crv_length = 0.0;
  crv.GetLength( ref crv_length );
  if( crv_length < OnUtil.On_ZERO_TOLERANCE )
    return IRhinoCommand.result.failure;

  MRhinoGetNumber gn = new MRhinoGetNumber();
  string s = string.Format("Curve length is {0:f3}. Segment length",crv_length);
  gn.SetCommandPrompt( s );
  gn.SetLowerLimit( 0.0, true );
  gn.SetUpperLimit( crv_length, true );
  gn.GetNumber();
  if(gn.CommandResult() != IRhinoCommand.result.success)
    return gn.CommandResult();

  double seg_length = gn.Number();
  int seg_count = (int)System.Math.Floor( crv_length / seg_length );
  double fractional_end = (seg_count * seg_length) / crv_length;

  double t0=0, t1=0;
  crv.GetDomain( ref t0, ref t1 );
  crv.GetNormalizedArcLengthPoint( fractional_end, ref t1);

  seg_count++;
  double[] t = new double[seg_count];

  for( int i = 0; i < seg_count; i++ )
  {
    double param = (double)i / ((double)seg_count-1);
    t[i] = param;
  }

  OnInterval sub_domain = new OnInterval(t0,t1);
  crv.GetNormalizedArcLengthPoints( t, ref t, 0.0, 1.0e-8, sub_domain );

  for( int i = 0; i < seg_count; i++ )
  {
    On3dPoint pt = crv.PointAt( t[i] );
    context.m_doc.AddPointObject( pt );
  }
  context.m_doc.Redraw();
  return IRhinoCommand.result.success;
}

</code>

===== VB.NET (using RhinoCommon) =====
<code vb>
Public Shared Function DivideByLengthPoints(ByVal doc As Rhino.RhinoDoc) As Rhino.Commands.Result
  Dim filter As Rhino.DocObjects.ObjectType = Rhino.DocObjects.ObjectType.Curve
  Dim objref As Rhino.DocObjects.ObjRef = Nothing
  Dim rc As Rhino.Commands.Result = Rhino.Input.RhinoGet.GetOneObject("Select curve to divide", False, filter, objref)
  If rc <> Rhino.Commands.Result.Success OrElse objref Is Nothing Then
    Return rc
  End If

  Dim crv As Rhino.Geometry.Curve = objref.Curve()
  If crv Is Nothing OrElse crv.IsShort(Rhino.RhinoMath.ZeroTolerance) Then
    Return Rhino.Commands.Result.Failure
  End If

  Dim crv_length As Double = crv.GetLength()
  Dim s As String = String.Format("Curve length is {0:f3}. Segment length", crv_length)

  Dim seg_length As Double = crv_length / 2.0
  rc = Rhino.Input.RhinoGet.GetNumber(s, False, seg_length, 0, crv_length)
  If rc <> Rhino.Commands.Result.Success Then
    Return rc
  End If

  Dim points As Rhino.Geometry.Point3d() = Nothing
  crv.DivideByLength(seg_length, True, points)
  If points Is Nothing Then
    Return Rhino.Commands.Result.Failure
  End If

  For Each point As Rhino.Geometry.Point3d In points
    doc.Objects.AddPoint(point)
  Next

  doc.Views.Redraw()
  Return Rhino.Commands.Result.Success
End Function
</code>

===== C# (using RhinoCommon) =====
<code c#>
public static Rhino.Commands.Result DivideByLengthPoints(Rhino.RhinoDoc doc)
{
  Rhino.DocObjects.ObjectType filter = Rhino.DocObjects.ObjectType.Curve; 
  Rhino.DocObjects.ObjRef objref = null;
  Rhino.Commands.Result rc = Rhino.Input.RhinoGet.GetOneObject("Select curve to divide", false, filter, out objref);
  if (rc != Rhino.Commands.Result.Success || objref == null)
    return rc;

  Rhino.Geometry.Curve crv = objref.Curve();
  if (crv == null || crv.IsShort(Rhino.RhinoMath.ZeroTolerance))
    return Rhino.Commands.Result.Failure;

  double crv_length = crv.GetLength();
  string s = string.Format("Curve length is {0:f3}. Segment length", crv_length);

  double seg_length = crv_length / 2.0;
  rc = Rhino.Input.RhinoGet.GetNumber(s, false, ref seg_length, 0, crv_length);
  if (rc != Rhino.Commands.Result.Success)
    return rc;

  Rhino.Geometry.Point3d[] points = null;
  crv.DivideByLength(seg_length, true, out points);
  if (points == null)
    return Rhino.Commands.Result.Failure;

  foreach (Rhino.Geometry.Point3d point in points)
    doc.Objects.AddPoint(point);

  doc.Views.Redraw();
  return Rhino.Commands.Result.Success;
}
</code>
{{tag>Developer cplusplus dotnet}}
