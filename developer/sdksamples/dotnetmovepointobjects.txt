====== Moving Point Objects ======
====== .NET ======
> **Summary:** //Demonstrates how to move point objects using the Rhino .NET SDK//
> **NOTICE:** //The Rhino.NET SDK is deprecated in Rhino 5.  Examples of this sample adapted for the new RhinoCommon SDK are [[developer:rhinocommonsamples:dotnetmovepointobjects|here]] and [[developer:rhinocommonsamples:dotnetmovepointobjectsnonuniform|here]]//
=====Question=====
Using C#, I have successfully picked a series of points and stored their XYZ coordinates into an ArrayList. I am now trying to move these points. Do I need to also store their object IDs into the ArrayList and reference these IDs to input new coordinates so that the points move? If so, what is the syntax for getting point IDs and giving them new XYZ values looping through the ArrayList of picked points?

=====Answer=====
All Rhino objects are able to be transformed using a 4x4 transformation matrix. The OnXform class will help you define your transformation. Once you have defined the transformation, use MRhinoDoc::TransformObject to apply the transformation to an exising Rhino object.

The following sample code demonstrates how to move one or more selected points objects from one location to another.

===== C# =====
<code c#>

  public override IRhinoCommand.result RunCommand(IRhinoCommandContext context)
  {
    MRhinoGetObject go = new MRhinoGetObject();
    go.SetCommandPrompt("Select point objects to move");
    go.SetGeometryFilter(IRhinoGetObject.GEOMETRY_TYPE_FILTER.point_object);
    go.GetObjects(1, 0);
    if (go.CommandResult() != IRhinoCommand.result.success)
      return go.CommandResult();

    MRhinoGetPoint gp = new MRhinoGetPoint();
    gp.SetCommandPrompt("Point to move from");
    gp.GetPoint();
    if (gp.CommandResult() != IRhinoCommand.result.success)
      return gp.CommandResult();

    On3dPoint start_pt = gp.Point();

    gp.SetCommandPrompt("Point to move to");
    gp.SetBasePoint(start_pt);
    gp.DrawLineFromPoint(start_pt, true);
    gp.GetPoint();
    if (gp.CommandResult() != IRhinoCommand.result.success)
      return gp.CommandResult();

    On3dPoint end_pt = gp.Point();

    On3dVector v = new On3dVector(end_pt - start_pt);
    if (v.IsTiny())
      return IRhinoCommand.result.nothing;

    OnXform xform = new OnXform();
    xform.Translation(v);

    for (int i = 0; i < go.ObjectCount(); i++)
    {
      MRhinoObjRef objref = go.Object(i);
      context.m_doc.TransformObject(ref objref, xform, true);
    }

    context.m_doc.Redraw();

    return IRhinoCommand.result.success;
  }

</code>
If you are not looking to apply a uniform transformation on each point object, then you will want to make a copy of the point object's 3-D point data, modify the data, and then use MRhinoDoc::ReplaceObject to modify the point object's geometry.

For example:

===== C# =====
<code c#>

  public override IRhinoCommand.result RunCommand(IRhinoCommandContext context)
  {
    MRhinoGetObject go = new MRhinoGetObject();
    go.SetCommandPrompt("Select point objects to move");
    go.SetGeometryFilter(IRhinoGetObject.GEOMETRY_TYPE_FILTER.point_object);
    go.GetObjects(1, 0);
    if (go.CommandResult() != IRhinoCommand.result.success)
      return go.CommandResult();

    for (int i = 0; i < go.ObjectCount(); i++)
    {
      MRhinoObjRef objref = go.Object(i);
      IOnPoint point_obj = objref.Point();
      if (point_obj == null)
        continue;

      On3dPoint pt = new On3dPoint(point_obj.point);
      // Modify the point coordinates in some way..
      pt.x++;
      pt.y++;
      pt.z++;

      context.m_doc.ReplaceObject(objref, pt);
    }

    context.m_doc.Redraw();

    return IRhinoCommand.result.success;
  }


</code>


{{tag>Developer dotnet}}
